domain ATQR

  context Challenges

    repository ChallengeRepository
      save challenge: Challenge

      findChallengeById :challengeId
        ⮐ Challenge or null

    service ChallengesService
      depends on ChallengeRepository

      💬 GetLastChallenges? amount
        returns the first amount Challenges ordered by challenge's createdAt descending

      💬 GetChallenge? :challengeId
          either findChallengeById :challengeId using ChallengeRepository
              or show ChallengeNotFound screen

    service DeadlineMonitor
      depends on ChallengesService

      /**
       * This is a cron job that runs every day and checks if any challenges are overdue
       *
       * ItsThatTimeAgain!
       *   @createdAt: DateTime
       */
      ⏰ NewDayStarted!
        for each :challenge in Challenges
          when .deadline is before Today
            📣 DeadlineReached! :challengeId

          // TODO: Check which logic is better for sending emails
          // This or the one inside NotificationService
          when .enrollmentDeadline is Today
            and .createdAt is before 2 days ago
            list all .invitees that
              - have not enrolled in :challengeId
              - have not been notified

            if list is not empty
              📣 PlayersForgotToEnroll! :challengeId :list

          when .createdAt is before 5 days ago
            and .enrollmentDeadline is Today
            list all .invitees that
              - have not enrolled in :challengeId
              - have been notified at most once

            if list is not empty
              📣 PlayersLastChanceToEnrollArrived! :challengeId :list

      💬 ChallengeDeadlineReached! :challenge
        if :challenge is not Accomplished
          mark :challenge as Failed

    /**
     * Definition of a service that handles emails
     * @type Infrastructure
     */
    service EmailService
      send
        params
          to: EmailAddress
          subject: string
          body: string

    /**
     * @type DomainService
     */
    service AccountService
      uses UserRepository

      createAccount for Contact
        rules:
          - Contact.email does not exist in UserRepository.users.email

    service NotificationService
      depends on EmailService
      depends on ChallengeRepository

      sendEmail template: EmailTemplate data: Object, to: EmailAddress
        {{using}} Pug
          parse template.subject with data as :subject
          parse template.body with data as :body
        create new Email ^to with :subject and :body
        send ${it} {{using}} IEmailService

      ⏰ NewDayStarted!
        for each :challenge in ChallengeRepository

          for each invitee with .role of Player in :challenge.invitees
            if it's participationStatus is Accepted or Rejected
              skip it

            if we've sent more than Settings.maxRetries emails
              sendEmail
                template: YourChallengerNeverShowedUpEmail
                data: Challenge
                to: :challenge.owner.email

              📣 InviteeAbandonedTheChallenge! :challengeId :invitee

            if last email sent is more than Settings.retryDelay days ago
              sendEmail
                template: YouHaveBeenChallengedEmail
                data: Challenge
                to: :invitee.email

      💬 ChallengeCreated! :challenge
        sendEmail
          params:
            template: ChallengeCreatedEmail
            data: Challenge
            to: :challenge.owner.email

        when :challenge.createdByPlayer
          for each contact in :challenge.invitees
            if it's role is Judge
              sendEmail
                template: OfficiationRequestedEmail
                data: Challenge
                to: :contact.email

            if it's role is Player
              sendEmail
                template: YouHaveBeenChallengedEmail
                data: Challenge
                to: :contact.email

      💬 FundsAvailable!
          send ChallengeCreatedEmailToPlayer

      💬 FundsDenied!
          send PaymentMethodDeniedEmail

      💬 SupervisionRequested!
          send SupervisionRequestEmail

      💬 SupervisionRequestAccepted!
          send SupervisionRequestAccepted

      💬 SupervisionRequestRejected!
          send SupervisorRejectedEmail

      💬 ChallengeAccepted! enrollment: Enrollment
          sendEmail
            params:
              template: ChallengeAcceptedEmail
              data: ^enrollment
              to: ^enrollment.judge.email

      💬 ChallengeRejected!
          params:
            - challenge: Challenge

          sendEmail with:
            template: ChallengeRejectedEmail
            data: ^challenge
            to: ^challenge.owner.email

      💬 ChallengeOngoing!
          send ChallengeOngoingEmailToPlayer

      💬 JudgeRequested!
          send JudgementRequestEmail

      💬 ChallengeAccomplished! :challenge
          sendEmail with:
            template: ChallengeAccomplishedEmail
            to: :challenge.enrollments[0].player.email
            data: :challenge

      💬 ChallengeFailed! :challenge
          sendEmail
            params:
              template: ChallengeFailedEmail
              to: :challenge.enrollments[0].player.email
              data: :challenge

      💬 AskPlayerForNewJudge! :challenge
          sendEmail
            params:
              template: emailAskPlayerForNewJudge
              to: challenge.player
              data: Challenge

      💬 RequestJudgeParticipation! :challenge :contactJudge
          sendEmail
            params:
              template: emailRequestJudgeParticipation
              to: contactJudge
              data: Challenge

    /**
     * Definition of a service that handles payments
     * @type Infrastructure
     */
    service PaymentService
      createCustomer from :contact => ForeignCustomerId

      createPaymentMethod for :customer with :paymentMethod
        return ForeignPaymentMethodId

      setupFuturePayment of :amount using :paymentMethod => FuturePaymentId

      capturePayment futurePaymentId
        // return SUCCESS or FAILURE
        return Whether it succeeded or not
