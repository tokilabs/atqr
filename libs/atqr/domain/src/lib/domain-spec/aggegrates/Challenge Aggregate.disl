domain ATQR

  context Challenges

    aggregate Challenge
      //TODO: Will it be implemented?
      !ChallengeNotFound :challengeId

      root Challenge
        depends on PaymentService

        @createdByPlayer: yes or no
          returns @owner's role as .Player

        @createdByJudge: yes or no
          returns @owner's role as .Judge

        @players: Enrollment[]
        @judges: Officiation[]
        @status: ChallengeStatus = .Unverified
        @createAt: DateTime
          auto: Today

        ‚öôÔ∏è recipe:
          @goalId: GoalId
          @owner: User
          /**
          * Holds all users ever invited to this challenge
          * and their participation status
          */
          @invitees: Invitee[]
          @deadline: Date
          @pledge: DISL.Money
            greater than 0
          @deadline: FutureDate
          @requiredProof?: DISL.Paragraph
          /**
           * Allows players to enroll using a link instead of being invited
           * @param {yes or no} yes if players can enroll using a link
           */
          @inviteByLink: yes or no
          @enrollmentDeadline: FutureDate
            before @deadline
          @owner: Contact

          //TODO: this "property" below was added to User entity as a property. Can it now be deleted from here?
          ownerPaymentMethod: PaymentMethod | null

          when @createdByPlayer
          // TODO: review, looks wrong (DONE)
          ‚öôÔ∏è registerPlayer :name :email
            rules:
              when @status == .Ongoing do nothing
              when User with ^email does not exist
                create new User for owner with ^name ^email
                  it's paymentMethod = PaymentMethod
                createEnrollmentFor User

              when User with ^email exists
                it's paymentMethod = PaymentMethod
                createEnrollmentFor User

                on SUCCESS:
                  show ui
                    CheckEmailToConfirmParticipation

                on FAILURE:
                  throw "Could not create player"

        /**
         * Represents the intention of a player to accept a challenge
         */
        -> AcceptChallenge? paymentInfo: Payment, inviteeEmail: Invitee.email
          rules:


          find ^invitee in @invitees where invitee.email == ^inviteeEmail

          if ^invitee is not found
            throw "Could not find invitee"

          ‚öôÔ∏è registerPlayer :name :email

          set ^invitee's participationStatus to .Accepted

          //TODO: Should have challengeId?
          publish ChallengeAccepted! :challengeId

        -> RejectChallenge? :inviteeEmail
          rules:
            when @status == ChallengeStatus.Ongoing do nothing

          find invitee in @invitees where invitee.email == :inviteeEmail

          if invitee is not found
            throw "Could not find invitee"

          set ^invitee's participationStatus to .Rejected

          //TODO: Should have challengeId?
          publish ChallengeRejected! :challengeId

        -> PlayerParticipationRequested?
          set invited player's participation status to ParticipationStatus.Requested

        -> RequestOfficiation? invitee: Invitee
          rules:
            when @status is not .Unverified or .Ongoing
              reject saying "You cannot request judge participation for this Challenge"
            when @createdByJudge
              reject saying "You cannot replace the judge since you created this Challenge"

          find the currently invited judge
            set it's status to ParticipationStatus.Canceled

          add ^invitee to invitees


          publish ChallengeGotANewInvitee! :challenge, invitee: Invitee
        -> InviteNewPlayer? contact: Contact
          rules:
            when @status is not .Unverified or .Abandoned
              reject saying "You cannot change the Player for a Challenge after if it's already started."

            when invited player's participationStatus is .Accepted
              reject saying "You cannot change the Player for a Challenge after they have accepted."

          find the currently invited player
            set it's participationStatus to .Rejected

          add invitee to @invitees

          publish ChallengeGotANewInvitee! :challenge, invitee: Invitee

          // TODO: Disparar evento ap√≥s envio de emails
          // TODO: Capturar evento na Challenge para alterar ParticipationStatus
          // TODO: Continuar review do beto
        -> PlayerParticipationRequested!
          set invited player's participation status to ParticipationStatus.Requested

        -> OfficiationRequested!
          set invited judge's participationStatus to .Requested

        //TODO: call method at all required places
        ‚öôÔ∏è verifyIfChallengeCanBegin :players :judges :paymentMethods
          return ‚öôÔ∏è allJudgesAccepted
            and  ‚öôÔ∏è allPlayersAccepted
            and  ‚öôÔ∏è allPaymentMethodsVerified

        ‚öôÔ∏è allPlayersAccepted
          for each invitee with .role equals Player in @invitees
            if it's participationStatus is not Accepted
              return false

          return true

        ‚öôÔ∏è allJudgesAccepted
          for each invitee with .role equals Judge in @invitees
            if it's participationStatus is not Accepted
              return false

        ‚öôÔ∏è allPaymentMethodsVerified
          for each enrollment in @enrollments
            if it's PaymentFundsStatus is not Authorized
              return false

        ‚öôÔ∏è createEnrollmentFor invitee
          create [new Enrollment] in @players for ^invitee
            it's pledge = 0
            it's paymentMethod = null
            it's paymentStatus = PaymentStatus.NotRequested
            it's paymentFundsStatus = PaymentFundsStatus.NotRequested

        ‚öôÔ∏è verifyFunds
          params:
              :challengeId
              paymentMethod: PaymentMethod

          PaymentService.verifyFunds for @pledge and paymentMethod

          rules:
            when :paymentFundsStatus == PaymentFundsStatus.Available
              publish fundsAvailable! :challengeId :paymentMethod
                sendChallengeCreatedEmailToPlayer? :challengeId

              when :officiationStatus == OfficiationStatus.Accepted
                @status = ChallengeStatus.Ongoing
                publish challengeOngoing! :challengeId
                  sendChallengeOngoingEmailToPlayer? :challengeId

            when :paymentFundsStatus == PaymentFundsStatus.Denied
              publish challengeFailed! :challengeId
                sendChallengeFailedEmailToPlayer? :challengeId

            // if Judge has accepted the request then

        -> rejectFundsRequest? :challengeId :paymentMethod
            @paymentMethod = PaymentFundsStatus.Denied
            publish fundsDenied! :challengeId :paymentMethod
                sendPaymentMethodDeniedEmail? :challengeId

        command AcceptOfficiationRequest? inviteeId: Unique Id
          when:
            ^inviteeId is not in @invitees
              throw "Could not find that invitee in this challenge"

          get [invitee] in @invitees
            where invitee.id is equal to ^inviteeId

          set ^invitee's participationStatus to .Accepted

          find_or_create a [User] for the ^invitee

          create a new [Officiation] for the ^User

            set Officiation's judge to ^User

          publish OfficiationRequestAccepted! :challengeId :judgeId

          ‚öôÔ∏è verifyIfChallengeCanBegin


        -> RejectOfficiationRequest? inviteeId: inviteeId

          set invited Judge's participationStatus to .Rejected

          publish OfficiationRequestRejected! :challengeId :judgeId

        -> JudgeChallenge? :userId, accomplished: boolean

          rules:
            when @status is not ChallengeStatus.Overdue
              throw "Challenge is not ongoing"

            when there is no Enrollment for :userId
              throw "User is not a player in this challenge"

          @challengeJudgement = ChallengeJudgement.Judged
          @status = ChallengeStatus.Finished

          if ^accomplished
            @enrollments[0].outcome = PlayerOutcome.Accomplished
            publish ChallengeAccomplished! this
          else
            @enrollments[0].outcome = PlayerOutcome.Failed
            publish ChallengeFailed! this

        ‚åõ DeadlineReached! :challengeId
          @status = ChallengeStatus.Overdue
          sendJudgementRequestEmail? :challengeId
            @challengeJudgement = ChallengeJudgement.Requested

        üìß ChallengeFailed!
          sendChallengeFailedEmail? :challengeId

      entity User
        @id: UserId { auto-generated }
        @emailConfirmed: yes or no
        @playedChallenges: Enrollment[]
        @officiatedChallenges: Officiation[]
        @organizedChallenges: Challenge[]
        @paymentMethod: PaymentMethod | null
        @notificationSettings:
          @channels: NotificationChannel[]
          @lists: NotificationList[]

        recipe:
          params:
            @name: DISL.FullName
            @email: DISL.EmailAddress { unique }

          publish UserCreated! :user

        /**
         * Returns all unanswered challenge invitations
         */
        ‚öôÔ∏è getPendingInvitations:
          returns The Challenges where this user is in .invitees[]
              AND .invitees[].status == ParticipationStatus.NotRequested

      entity PaymentMethod
        depends on PaymentService

        /**
         * The id of the payment method in the payment service
         */
        @foreignId: ForeignPaymentMethodId
        @type: PaymentMethodType
        @paymentService: "stripe"
        @futurePayments: Map<ChallengeId, FuturePaymentId>

        üìß CardCharged! :auth :amountInCents

        ‚öôÔ∏è setupFuturePayment: amountInCents
          // TODO: Implement this

        /**
         * Uses Stripe to charge the card using the pre-authorization
         *
         * @param {PreAuthorization} auth The pre-authorization to use
         * @param {number} amountInCents The amount to charge in cents
         * @returns {boolean} Whether the charge was successful or not
         */
        ‚öôÔ∏è charge
          params:
            foreignId: FuturePaymentId

          when PaymentService.capturePayment(foreignId) succeeds
            ‚Æê SUCCESS
          else
            CardChargeFailed! :auth :amountInCents
            ‚Æê FAILED

        ‚öôÔ∏è ReleasePreAuth? :preAuthorization
