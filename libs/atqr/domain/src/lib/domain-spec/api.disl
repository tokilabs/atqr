# import other DISL files
read_also enums.disl
read_also ui.disl

alias :challenge challenge Challenge
alias :dt date DateTime
alias :name fullName string
alias :id id Guid

domain ATQR
  purpose "A platform for people to challenge each other to accomplish goals"

context TheGame

  valueObject EmailAddress
    @value: EmailAddress

  valueObject Contact
    @name: DISL.FullName
    @email: DISL.EmailAddress

  aggregate ChallengeAggregate

    !ChallengeNotFound :challengeId

    root Player
      @id: Guid
      @name: string
      @email: EmailAddress
      @challenges: Challenge[]

      events:
        PlayerCreated! newPlayer: Player

      /**
       * Creates a new player and fires a PlayerCreated event
       *
       * NOTE: Commands in DISL are semantic and do not always mean
       * that a method should be created with the same name.
       * In this case, the CreatePlayer command will be translated
       * to the Player entity's constructor.
       */
      CreatePlayer? @:name @:email
        -> PlayerCreated!

    entity Challenge
      @price: Money
      @deadline: Date
      @goal: Phrase
      @player: Player
      @supervisor: Contact
      @paymentMethod?: PaymentMethod
      # Challenge Status should only be set to Ongoing when funds and supervisor are verified!
      @status: ChallengeStatus = ChallengeStatus.Unverified
      @supervisionStatus: SupervisionStatus = SupervisionStatus.NotRequested
      @paymentFundsStatus: PaymentFundsStatus = PaymentFundsStatus.Unverified
      @challengeJudgement: ChallengeJudgement = ChallengeJudgement.NotRequested
      @createdByPlayer: boolean

      /**
       * Creates a new challenge and notifies both the Player and the Supervisor
       */
      CreateChallenge?
        params:
        - @:goal
        - @:supervisor: Contact
        - @:player: Contact
        - @:price
        - @:deadline: FutureDate
        - @:paymentMethod
        ChallengeCreated! :id :goal :supervisorName :supervisorEmail :player :price :deadline :paymentMethod :challengeStatus :supervisorStatus
          rules:
            when :price
            when @createdByPlayer
              verifyFunds? :challengeId
                fundsVerified! :challengeId :paymentFundsStatus
              sendSupervisionRequestedEmail? :challengeId
                supervisionRequested! :challengeId
            else
              sendChallengeCreatedEmailToSupervisor? :challengeId
              sendYouHaveBeenChallengedEmail? :challengeId
                playerChallenged! :challengeId

      /**
       * Represents the intention of a player to accept a challenge
       */
      AcceptChallenge? :challengeId paymentInfo: Payment
        rules:
          when :challengeId not in Challenges
            throw ChallengeNotFound
          when @status == ChallengeStatus.Ongoing do nothing

        @status = ChallengeStatus.Accepted
        challengeAccepted! :challengeId
          sendChallengeAcceptedEmailToPlayer? :challengeId
      RejectChallenge? :challengeId

      GetLastChallenges? :qty
        return the first :qty Challenges ordered by @creation_date descending
          source: database

      fundsVerified! :challengeId :paymentFundsStatus
        rules:
          when :paymentFundsStatus == PaymentFundsStatus.Available
            fundsAvailable! :challengeId :paymentMethod
              sendChallengeCreatedEmailToPlayer? :challengeId

            when :supervisionStatus == SupervisionStatus.Accepted
              @status = ChallengeStatus.Ongoing
              challengeOngoing! :challengeId
                sendChallengeOngoingEmailToPlayer? :challengeId

          when :paymentFundsStatus == PaymentFundsStatus.Denied
            challengeFailed! :challengeId
              sendChallengeFailedEmailToPlayer? :challengeId

          # if Supervisor has accepted the request then
      rejectFundsRequest? :challengeId :paymentMethod
          @paymentMethod = PaymentFundsStatus.Denied
          fundsDenied! :challengeId :paymentMethod
              sendPaymentMethodDeniedEmail? :challengeId


      acceptSupervisionRequest? :challengeId :supervisorId
        @supervisorStatus = SupervisionStatus.Accepted
        supervisionRequestAccepted! :challengeId :supervisorId
          # if Funds are verified then
          when @paymentFundsStatus is PaymentFundsStatus.Available
            @status = ChallengeStatus.Ongoing

      rejectSupervisionRequest? :challengeId :supervisorId
        @supervisorStatus = SupervisionStatus.Rejected
        supervisionRequestRejected! :challengeId :supervisorId
          sendSupervisorRejectedEmail? :challengeId



      inviteNewSupervisor? :challengeId :supervisorName :supervisorEmail
        @supervisorStatus = SupervisionStatus.Requested
        sendSupervisionRequestedEmail? :challengeId
          supervisionRequested! :challengeId

      /**
       * This is a cron job that runs every day and checks if any challenges are overdue
       */
      aDayHasPassed!
        checkChallengeDeadline? :challengeId
          rules:
            when @deadline < Date.now() => deadlineReached! :challengeId

      deadlineReached! :challengeId
        @status = ChallengeStatus.Overdue
        sendJudgementRequestEmail? :challengeId
          @challengeJudgement = ChallengeJudgement.Requested

      judgeChallenge? :challengeId, accomplished: boolean
        @challengeJudgement = ChallengeJudgement.Judged
        @status = accomplished ? ChallengeStatus.Accomplished : ChallengeStatus.Failed
        when accomplished
          challengeAccomplished! :challengeId
            sendChallengeAccomplishedEmail? :challengeId
        else
          challengeFailed! :challengeId
            sendChallengeFailedEmail? :challengeId

    entity PaymentMethod
      @type: PaymentMethodType
      @paymentService: string
      @token: string

      verifyFunds? :challenge
      preAuthCharge? :challenge
      chargeCard? :challenge
