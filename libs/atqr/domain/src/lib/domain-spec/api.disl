// import other DISL files
read_also enums.disl
read_also ui.disl

// Creates new types that extend Guid to differentiate among Entity Ids
identity ChallengeId: Guid
identity UserId: Guid

alias :challenge challenge Challenge
alias :challengeId id ChallengeId
alias :userId id UserId
alias :dt date DateTime
alias :name fullName DISL.FullName
alias :id id Guid

domain ATQR
  purpose "A platform for people to challenge each other to accomplish goals"

  // System events
  //------------------
  /**
   * Fired each new day at 00:00:01
   */
  ⏰ NewDayStarted!

  context Challenges

    aggregate Goals
      root Goal
        @title: string
        @challenges: Challenge[]
        @pursuers: returns @challenges.map(c => c.enrollments.map(e => e.player)).flat()

        stories:
          - stories/visitorAdoptsGoal

        💬 CreateGoal? :title
          create new Goal with :title
          📣 GoalCreated! :goal

        /**
         * Creates a new challenge and notifies both the Player and the Supervisor
         */
        💬 CreateChallenge?
          params:
            goalId: GoalId
            pledge: DISL.Money
                greater than 0
            deadline: FutureDate
            invitees: Invitee[]
            requiredProof?: DISL.Paragraph
            /**
             * Allows players to enroll using a link instead of being invited
             * @param {boolean} true if players can enroll using a link
             */
            inviteByLink: boolean
            enrollmentDeadline: FutureDate
                before @deadline
            owner: Contact
            ownerPaymentMethod: PaymentMethod | null

          // We must create the User first to ensure
          // that we collect their email address (for marketing purposes)
          find_or_create new User from owner

          rules:
            when @createdByPlayer
              if ownerPaymentMethod is not defined
                throw "A player must have a payment method defined"

              if PaymentService .authorizeCharge for pledge and ownerPaymentMethod FAILED
                throw "Could not authorize payment"

              the new User's paymentMethod = ownerPaymentMethod

              create new Challenge with the parameters received

              createEnrollmentFor the new User
                add it to the new Challenge's enrollments

              📣 ChargeAuthorized! @owner @pledge ownerPaymentMethod
              📣 ChallengeCreated! this

            when @createdByJudge
              create new Challenge with the parameters received

              create new Officiation for owner
                add it to the new Challenge's judges

              📣 ChallengeCreated! this

    aggregate ChallengeAggregate

      !ChallengeNotFound :challengeId

      root Challenge
        depends on PaymentService

        @createdByPlayer: boolean
          returns @owner.role == ParticipationRole.Player

        @createdByJudge: boolean
          returns @owner.role == ParticipationRole.Judge

        @players: Enrollment[]
        @judges: Officiation[]
        @status: ChallengeStatus = ChallengeStatus.Unverified
        @createAt: DateTime
          auto: Today

        ⚙️ recipe:
          params:
            @goalId: GoalId
            @owner: User
            /**
            * Holds all users ever invited to this challenge
            * and their participation status
            */
            @invitees: Contact[]
            @deadline: Date
            @pledge: DISL.Money
              greater than 0
            @deadline: FutureDate
            @requiredProof?: DISL.Paragraph
            /**
             * Allows players to enroll using a link instead of being invited
             * @param {boolean} true if players can enroll using a link
             */
            @inviteByLink: boolean
            @enrollmentDeadline: FutureDate
              before @deadline
            @owner: Contact
            ownerPaymentMethod: PaymentMethod | null

          when @createdByPlayer
            create new User for owner
              it's paymentMethod = ownerPaymentMethod

            createEnrollmentFor owner

        ⚙️ registerPlayer :name :email
          rules:
            when User with :email does not exist
              create new User with :name :email
                on SUCCESS:
                  show ui CheckEmailToConfirmParticipation
                on FAILURE:
                  throw "Could not create player"

        /**
         * Represents the intention of a player to accept a challenge
         */
        💬 AcceptChallenge? paymentInfo: Payment
          rules:
            when @status == ChallengeStatus.Ongoing do nothing

          if invitee is not found
            throw "Could not find invitee"

          invitee.status = ParticipationStatus.Accepted

          createEnrollmentFor invitee

          📣 ChallengeAccepted! :challengeId

        💬 RejectChallenge? :challengeId :inviteeEmail
          rules:
            when :challengeId not in Challenges
              throw ChallengeNotFound

            when @status == ChallengeStatus.Ongoing do nothing

          find invitee in @invitees where invitee.email == :inviteeEmail

          if invitee is not found
            throw "Could not find invitee"

          invitee.status = ParticipationStatus.Rejected

          📣 ChallengeRejected! :challengeId

        ⚙️ createEnrollmentFor invitee
          create enrollment in @players for invitee
            it's pledge = 0
            it's paymentMethod = null
            it's paymentStatus = PaymentStatus.NotRequested
            it's paymentFundsStatus = PaymentFundsStatus.NotRequested

        ⚙️ verifyFunds
          params:
              :challengeId
              paymentMethod: PaymentMethod

          PaymentService.verifyFunds for @pledge and paymentMethod

          rules:
            when :paymentFundsStatus == PaymentFundsStatus.Available
              📣 fundsAvailable! :challengeId :paymentMethod
                sendChallengeCreatedEmailToPlayer? :challengeId

              when :supervisionStatus == SupervisionStatus.Accepted
                @status = ChallengeStatus.Ongoing
                📣 challengeOngoing! :challengeId
                  sendChallengeOngoingEmailToPlayer? :challengeId

            when :paymentFundsStatus == PaymentFundsStatus.Denied
              📣 challengeFailed! :challengeId
                sendChallengeFailedEmailToPlayer? :challengeId

          # if Supervisor has accepted the request then
        💬 rejectFundsRequest? :challengeId :paymentMethod
            @paymentMethod = PaymentFundsStatus.Denied
            📣 fundsDenied! :challengeId :paymentMethod
                sendPaymentMethodDeniedEmail? :challengeId

        💬 AcceptSupervisionRequest? :challengeId :supervisorId
          @supervisorStatus = SupervisionStatus.Accepted
          📣 supervisionRequestAccepted! :challengeId :supervisorId
            # if Funds are verified then
            when @paymentFundsStatus is PaymentFundsStatus.Available
              @status = ChallengeStatus.Ongoing

        💬 RejectSupervisionRequest? :challengeId :supervisorId
          @supervisorStatus = SupervisionStatus.Rejected
          📣 supervisionRequestRejected! :challengeId :supervisorId
          sendSupervisorRejectedEmail? :challengeId

        💬 InviteNewSupervisor? :challengeId :supervisorName :supervisorEmail
          @supervisorStatus = SupervisionStatus.Requested
          sendSupervisionRequestedEmail? :challengeId
            📣 supervisionRequested! :challengeId


        💬 JudgeChallenge? :challengeId, accomplished: boolean
          @challengeJudgement = ChallengeJudgement.Judged
          @status = accomplished ? ChallengeStatus.Accomplished : ChallengeStatus.Failed
          when accomplished
            📣 ChallengeAccomplished! :challengeId
              sendChallengeAccomplishedEmail? :challengeId
          else
            📣 ChallengeFailed! :challengeId

        /**
         * This is a cron job that runs every day and checks if any challenges are overdue
         *
         * ItsThatTimeAgain!
         *   @createdAt: DateTime
         */
        ⏰ NewDayStarted!
          for each :challenge in Challenges
            when .deadline is before Today
              📣 DeadlineReached! :challengeId

            when .createdAt is before 2 days ago
              and .enrollmentDeadline is after Yesterday
              list all .invitees that
                - have not enrolled in :challengeId
                - have not been notified

              if list is not empty
                📣 PlayersForgotToEnroll! :challengeId :list

            when .createdAt is before 5 days ago
              and .enrollmentDeadline is Today
              list all .invitees that
                - have not enrolled in :challengeId
                - have been notified at most once

              if list is not empty
                📣 PlayersLastChanceToEnrollArrived! :challengeId :list

        ⌛ DeadlineReached! :challengeId
          @status = ChallengeStatus.Overdue
          sendJudgementRequestEmail? :challengeId
            @challengeJudgement = ChallengeJudgement.Requested

        📧 ChallengeFailed!
          sendChallengeFailedEmail? :challengeId

      entity User
        @id: UserId { auto-generated }
        @emailConfirmed: boolean
        @playedChallenges: Enrollment[]
        @officiatedChallenges: Officiation[]
        @organizedChallenges: Challenge[]

        recipe:
          params:
            @name: DISL.FullName
            @email: DISL.EmailAddress { unique }

          📣 UserCreated! :user

        /**
         * Returns all unanswered challenge invitations
         */
        ⚙️ getPendingInvitations:
          returns The Challenges where this user is in .invitees[]
              AND .invitees[].status == ParticipationStatus.NotRequested

      entity PaymentMethod
        depends on PaymentService

        /**
         * The id of the payment method in the payment service
         */
        @foreignId: ForeignPaymentMethodId
        @type: PaymentMethodType
        @paymentService: "stripe"
        @futurePayments: Map<ChallengeId, FuturePaymentId>

        📧 CardCharged! :auth :amountInCents

        ⚙️ setupFuturePayment: amountInCents
          // TODO: Implement this

        /**
         * Uses Stripe to charge the card using the pre-authorization
         *
         * @param {PreAuthorization} auth The pre-authorization to use
         * @param {number} amountInCents The amount to charge in cents
         * @returns {boolean} Whether the charge was successful or not
         */
        ⚙️ charge
          params:
            foreignId: FuturePaymentId

          when PaymentService.capturePayment(foreignId) succeeds
            ⮐ SUCCESS
          else
            CardChargeFailed! :auth :amountInCents
            ⮐ FAILED

        ⚙️ ReleasePreAuth? :preAuthorization
