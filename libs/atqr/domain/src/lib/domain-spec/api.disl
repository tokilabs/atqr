// import other DISL files
read also enums.disl
read also ui.disl

// Creates new types that extend Guid to differentiate among Entity Ids
concept ChallengeId expands on Guid
concept UserId expands on Guid
concept GoalId expands on Guid
concept SupervisorId expands on Guid

alias :challenge to challenge: Challenge
alias :challengeId to id: ChallengeId
alias :supervisorId to supervisorId: SupervisorId
alias :userId to id: UserId
alias :date to date: DateTime
alias :name to fullName: DISL.FullName
alias :id to id: Guid

domain ATQR
  purpose "A platform for people to challenge each other to accomplish goals"

  concept Settings
    emails:
      retryDelay: $> number of emails sent * 2
      maxRetries: 3 times
      maxEmailsPerAddress: 5
      maxEmailsResetPeriod: 1 month

  //------------------------------
  // System events
  //------------------

  /**
   * Fired each new day at 00:00:01
   */
  â° NewDayStarted!
    @date: DateTime

  context Challenges

    repository Notifications
      recordNotification NotificationMessage
      countNotifications
        params
          :userId
          optional inCategories: NotificationCategory[]
          optional sentVia: NotificationChannel[]

    aggregate ChallengeAggregate

      !ChallengeNotFound :challengeId

      root Challenge

        depends on PaymentService

        @createdByPlayer: boolean
          returns @owner.role == ParticipationRole.Player

        @createdByJudge: boolean
          returns @owner.role == ParticipationRole.Judge

        @players: Enrollment[]
        @judges: Officiation[]
        @status: ChallengeStatus = ChallengeStatus.Unverified
        @createAt: DateTime
          auto: Today

        âš™ï¸ recipe:
          @goalId: GoalId
          @owner: User
          /**
          * Holds all users ever invited to this challenge
          * and their participation status
          */
          @invitees: Contact[]
          @deadline: Date
          @pledge: DISL.Money
            greater than 0
          @deadline: FutureDate
          @requiredProof?: DISL.Paragraph
          /**
           * Allows players to enroll using a link instead of being invited
           * @param {boolean} true if players can enroll using a link
           */
          @inviteByLink: boolean
          @enrollmentDeadline: FutureDate
            before @deadline
          @owner: Contact
          ownerPaymentMethod: PaymentMethod | null

          when @createdByPlayer
            create new User for owner
              it's paymentMethod = ownerPaymentMethod

            createEnrollmentFor owner

        âš™ï¸ registerPlayer :name :email
          rules:
            when User with :email does not exist
              create new User with :name :email
                on SUCCESS:
                  show ui CheckEmailToConfirmParticipation
                on FAILURE:
                  throw "Could not create player"

        /**
         * Represents the intention of a player to accept a challenge
         */
        ğŸ’¬ AcceptChallenge? paymentInfo: Payment
          rules:
            when @status == ChallengeStatus.Ongoing do nothing

          if invitee is not found
            throw "Could not find invitee"

          invitee.status = ParticipationStatus.Accepted

          createEnrollmentFor invitee

          ğŸ“£ ChallengeAccepted! :challengeId

        ğŸ’¬ RejectChallenge? :challengeId :inviteeEmail
          rules:
            when :challengeId not in Challenges
              throw ChallengeNotFound

            when @status == ChallengeStatus.Ongoing do nothing

          find invitee in @invitees where invitee.email == :inviteeEmail

          if invitee is not found
            throw "Could not find invitee"

          invitee.status = ParticipationStatus.Rejected

          ğŸ“£ ChallengeRejected! :challengeId

        âš™ï¸ verifyIfChallengeCanBegin @players @judges @paymentMethods
          return allJudgeAccepted
            and  allPlayersAccepted
            and  allPaymentMethodsVerified

        âš™ï¸ allPlayersAccepted
          // code: this.invitees.find(invitee => invitee.role == player && invitee.participationStatus === ParticipationStatus.Accepted == false ? false : true)
          for each invitee with .role equals Player in @invitees
            if it's participationStatus is not Accepted
              return false

          return true

        âš™ï¸ allJudgesAccepted
          for each invitee with .role equals Judge in @invitees
            if it's participationStatus is not Accepted
              return false

        âš™ï¸ allPaymentMethodsVerified
          for each enrollment in @enrollments
            if it's PaymentFundsStatus is not Authorized
              return false

        âš™ï¸ createEnrollmentFor invitee
          create enrollment in @players for invitee
            it's pledge = 0
            it's paymentMethod = null
            it's paymentStatus = PaymentStatus.NotRequested
            it's paymentFundsStatus = PaymentFundsStatus.NotRequested

        âš™ï¸ verifyFunds
          params:
              :challengeId
              paymentMethod: PaymentMethod

          PaymentService.verifyFunds for @pledge and paymentMethod

          rules:
            when :paymentFundsStatus == PaymentFundsStatus.Available
              ğŸ“£ fundsAvailable! :challengeId :paymentMethod
                sendChallengeCreatedEmailToPlayer? :challengeId

              when :supervisionStatus == SupervisionStatus.Accepted
                @status = ChallengeStatus.Ongoing
                ğŸ“£ challengeOngoing! :challengeId
                  sendChallengeOngoingEmailToPlayer? :challengeId

            when :paymentFundsStatus == PaymentFundsStatus.Denied
              ğŸ“£ challengeFailed! :challengeId
                sendChallengeFailedEmailToPlayer? :challengeId

            // if Supervisor has accepted the request then

        ğŸ’¬ rejectFundsRequest? :challengeId :paymentMethod
            @paymentMethod = PaymentFundsStatus.Denied
            ğŸ“£ fundsDenied! :challengeId :paymentMethod
                sendPaymentMethodDeniedEmail? :challengeId

        ğŸ’¬ AcceptSupervisionRequest? :challengeId :supervisorId
          @supervisorStatus = SupervisionStatus.Accepted
          ğŸ“£ supervisionRequestAccepted! :challengeId :supervisorId
            # if Funds are verified then
            when @paymentFundsStatus is PaymentFundsStatus.Available
              @status = ChallengeStatus.Ongoing

        command RejectSupervisionRequest?
          params:
            - challengeId: ChallengeId
            :supervisorId
          @supervisorStatus = SupervisionStatus.Rejected
          ğŸ“£ supervisionRequestRejected! :challengeId :supervisorId
          sendSupervisorRejectedEmail? :challengeId

        ğŸ’¬ InviteNewSupervisor? :challengeId :supervisorName :supervisorEmail
          @supervisorStatus = SupervisionStatus.Requested
          sendSupervisionRequestedEmail? :challengeId
            ğŸ“£ supervisionRequested! :challengeId

        ğŸ’¬ JudgeChallenge? :userId, accomplished: boolean

          rules:
            when @status is not ChallengeStatus.Overdue
              throw "Challenge is not ongoing"

            when there is no Enrollment for :userId
              throw "User is not a player in this challenge"

          @challengeJudgement = ChallengeJudgement.Judged
          @status = ChallengeStatus.Finished

          if ^accomplished
            @enrollments[0].outcome = PlayerOutcome.Accomplished
            ğŸ“£ ChallengeAccomplished! this
          else
            @enrollments[0].outcome = PlayerOutcome.Failed
            ğŸ“£ ChallengeFailed! this

        âŒ› DeadlineReached! :challengeId
          @status = ChallengeStatus.Overdue
          sendJudgementRequestEmail? :challengeId
            @challengeJudgement = ChallengeJudgement.Requested

        ğŸ“§ ChallengeFailed!
          sendChallengeFailedEmail? :challengeId

      entity User
        @id: UserId { auto-generated }
        @emailConfirmed: boolean
        @playedChallenges: Enrollment[]
        @officiatedChallenges: Officiation[]
        @organizedChallenges: Challenge[]
        @notificationSettings:
          @channels: NotificationChannel[]
          @lists: NotificationList[]

        recipe:
          params:
            @name: DISL.FullName
            @email: DISL.EmailAddress { unique }

          ğŸ“£ UserCreated! :user

        /**
         * Returns all unanswered challenge invitations
         */
        âš™ï¸ getPendingInvitations:
          returns The Challenges where this user is in .invitees[]
              AND .invitees[].status == ParticipationStatus.NotRequested

      entity PaymentMethod
        depends on PaymentService

        /**
         * The id of the payment method in the payment service
         */
        @foreignId: ForeignPaymentMethodId
        @type: PaymentMethodType
        @paymentService: "stripe"
        @futurePayments: Map<ChallengeId, FuturePaymentId>

        ğŸ“§ CardCharged! :auth :amountInCents

        âš™ï¸ setupFuturePayment: amountInCents
          // TODO: Implement this

        /**
         * Uses Stripe to charge the card using the pre-authorization
         *
         * @param {PreAuthorization} auth The pre-authorization to use
         * @param {number} amountInCents The amount to charge in cents
         * @returns {boolean} Whether the charge was successful or not
         */
        âš™ï¸ charge
          params:
            foreignId: FuturePaymentId

          when PaymentService.capturePayment(foreignId) succeeds
            â® SUCCESS
          else
            CardChargeFailed! :auth :amountInCents
            â® FAILED

        âš™ï¸ ReleasePreAuth? :preAuthorization
