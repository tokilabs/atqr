``# import other DISL files
read_also enums.disl
read_also ui.disl

alias :challenge challenge Challenge
alias :dt date DateTime
alias :name fullName string
alias :id id Guid

domain ATQR
  purpose "A platform for people to challenge each other to accomplish goals"

context TheGame

  valueObject EmailAddress
    @value: DISL.EmailAddress

  valueObject Contact
    @name: DISL.FullName
    @email: DISL.EmailAddress

  // Creates a new type that is a Guid to differentiate among Entity Ids
  // export type PlayerId = Guid
  identity PlayerId: Guid

  aggregate ChallengeAggregate

    !ChallengeNotFound :challengeId

    entity User
      @id: UserId { auto-generated }
      @name: DISL.FullName
      @email: EmailAddress { unique }
      @judgingChallenges: Challenge[]
      @playingChallenges: Challenge[]
      @paymentMethod?: PaymentMethod

    valueObject Player
      @player: User
      @playerAlias?: DISL.Name
      @judge: User
      @outcome: PlayerOutcome
      @paymentStatus: PaymentStatus

      rules:
        when player == judge
          throw "A player cannot be a judge of his own challenge"

        when player .paymentMethod is not defined
          throw "A player must have a payment method defined"

    root Challenge
      @players: Players[]
      @status: ChallengeStatus = ChallengeStatus.Unverified
      @supervisionStatus: SupervisionStatus = SupervisionStatus.NotRequested
      @paymentFundsStatus: PaymentFundsStatus = PaymentFundsStatus.Unverified
      @challengeJudgement: ChallengeJudgement = ChallengeJudgement.NotRequested

      @openToAnyone: boolean

      /**
       * Creates a new challenge and notifies both the Player and the Supervisor
       */
      üü¢ CreateChallenge?
        params:
          - @goal: DISL.Phrase
          - @price: DISL.Money
          - supervisor: Contact
          - player: Contact
          - deadline: FutureDate
          - @createdByPlayer: boolean
          - @requiredProof?: DISL.Paragraph
          - @paymentMethod?: PaymentMethod

        -> ChallengeCreated! newChallenge: Challenge

        rules:
          when @createdByPlayer
            if @paymentMethod.authorizeCharge?(:price, :paymentMethod) succeeds
              @paymentFundsStatus = PaymentFundsStatus.Authorized
              ChargeAuthorized! :challengeId :paymentFundsStatus

            sendSupervisionRequestedEmail? :challengeId
              supervisionRequested! :challengeId
          else
            sendChallengeCreatedEmailToSupervisor? :challengeId
            sendYouHaveBeenChallengedEmail? :challengeId
              playerChallenged! :challengeId
      // end CreateChallenge

      /**
       * Creates a new player and fires a PlayerCreated event
       *
       * NOTE: Commands in DISL are semantic and do not always mean
       * that a method should be created with the same name.
       * In this case, the CreatePlayer command will be translated
       * to the Player entity's constructor.
       */
      CreateUser? :name :email
        create new User with :name :email as :user
        -> UserCreated! :user

      RegisterPlayer? :name :email
        rules:
          when Player with :email does not exist
            CreateUser? :name :email
              on SUCCESS:
                show ui CheckEmailToConfirmParticipation
              on FAILURE:
                throw "Could not create player"


      /**
       * Represents the intention of a player to accept a challenge
       */
      AcceptChallenge? :challengeId paymentInfo: Payment
        rules:
          when :challengeId not in Challenges
            throw ChallengeNotFound
          when @status == ChallengeStatus.Ongoing do nothing

        @status = ChallengeStatus.Accepted
        challengeAccepted! :challengeId
          sendChallengeAcceptedEmailToPlayer? :challengeId
      RejectChallenge? :challengeId

      GetLastChallenges? :qty
        return the first :qty Challenges ordered by @creation_date descending
          source: database

      fundsVerified! :challengeId :paymentFundsStatus
        rules:
          when :paymentFundsStatus == PaymentFundsStatus.Available
            fundsAvailable! :challengeId :paymentMethod
              sendChallengeCreatedEmailToPlayer? :challengeId

            when :supervisionStatus == SupervisionStatus.Accepted
              @status = ChallengeStatus.Ongoing
              challengeOngoing! :challengeId
                sendChallengeOngoingEmailToPlayer? :challengeId

          when :paymentFundsStatus == PaymentFundsStatus.Denied
            challengeFailed! :challengeId
              sendChallengeFailedEmailToPlayer? :challengeId

          # if Supervisor has accepted the request then
      üü¢ rejectFundsRequest? :challengeId :paymentMethod
          @paymentMethod = PaymentFundsStatus.Denied
          fundsDenied! :challengeId :paymentMethod
              sendPaymentMethodDeniedEmail? :challengeId


      üö¶ AcceptSupervisionRequest? :challengeId :supervisorId
        @supervisorStatus = SupervisionStatus.Accepted
        supervisionRequestAccepted! :challengeId :supervisorId
          # if Funds are verified then
          when @paymentFundsStatus is PaymentFundsStatus.Available
            @status = ChallengeStatus.Ongoing

      üö• RejectSupervisionRequest? :challengeId :supervisorId
        @supervisorStatus = SupervisionStatus.Rejected
        supervisionRequestRejected! :challengeId :supervisorId
          sendSupervisorRejectedEmail? :challengeId


      üïπ InviteNewSupervisor? :challengeId :supervisorName :supervisorEmail
        @supervisorStatus = SupervisionStatus.Requested
        sendSupervisionRequestedEmail? :challengeId
          supervisionRequested! :challengeId


      üí¨ judgeChallenge? :challengeId, accomplished: boolean
        @challengeJudgement = ChallengeJudgement.Judged
        @status = accomplished ? ChallengeStatus.Accomplished : ChallengeStatus.Failed
        when accomplished
          ChallengeAccomplished! :challengeId
            sendChallengeAccomplishedEmail? :challengeId
        else
          ChallengeFailed! :challengeId

      /**
       * This is a cron job that runs every day and checks if any challenges are overdue
       *
       * ItsThatTimeAgain!
       *   @createdAt: DateTime
       */
      ‚è∞ NewDayStarted!
        checkChallengeDeadline? :challengeId
          rules:
            when @deadline is before Today
              üîî DeadlineReached! :challengeId

      ‚åõ DeadlineReached! :challengeId=================
        @status = ChallengeStatus.Overdue
        sendJudgementRequestEmail? :challengeId
          @challengeJudgement = ChallengeJudgement.Requested

      üìß ChallengeFailed!
        sendChallengeFailedEmail? :challengeId

    valueObject PreAuthorization
      @code: DISL.Token
      @amount: DISL.Money
      // TODO: Check if Stripe returns an authorization code
      @createdAt: DateTime
      /**
      * The authorization expires in 30 days
      */
      @expiresAt: DateTime
        // ‚óå - Not implemented
        // ‚óØ - Implemented
        // ‚óè - Implemented and in use
        rules ‚óå ‚óØ ‚óè
          ‚óå Is future date
          ‚óå Is before 31 days from @createdAt

    /**
    * Service that handles payments
    * Implementation layer: Infrastructure
    */
    service IPaymentService
      üéõ createCustomer? :contact
        return ForeingCustomerId

      üéõ createPaymentMethod? :customer :paymentMethod
        return ForeignPaymentMethodId

      üéõ setupFuturePayment? :amount :paymentMethod
        return FuturePaymentId

      üéõ capturePayment? futurePaymentId: FuturePaymentId
        return boolean


    entity PaymentMethod
      /**
       * The id of the payment method in the payment service
       */
      @foreignId: ForeignPaymentMethodId
      @type: PaymentMethodType
      @paymentService: string
      @futurePayments: Map<ChallengeId, FuturePaymentId>
Ô∏é
      ‚ùó CardCharged! :auth :amountInCents

       SetupFuturePayment? :amountInCents

      /**
       * Uses Stripe to charge the card using the pre-authorization
       *
       * @param {PreAuthorization} auth The pre-authorization to use
       * @param {number} amountInCents The amount to charge in cents
       * @returns {boolean} Whether the charge was successful or not
       */
      ‚ùì Charge? foreignId: FuturePaymentId
        when IPaymentService.capturePayment(foreignId) succeeds
          ‚éã ‚Ü© SUCCESS
        else
          ‚ö°Ô∏è CardChargeFailed! :auth :amountInCents
          ‚Æê FAILED

      ‚åò releasePreAuth? :preAuthorization

valueObject Icons
