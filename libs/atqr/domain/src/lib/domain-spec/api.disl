// import other DISL files
read also enums.disl
read also ui.disl

// Creates new types that extend Guid to differentiate among Entity Ids
concept ChallengeId expands on Guid
concept UserId expands on Guid
concept GoalId expands on Guid
concept SupervisorId expands on Guid

alias :challenge to challenge: Challenge
alias :challengeId to id: ChallengeId
alias :supervisorId to supervisorId: SupervisorId
alias :userId to id: UserId
alias :date to date: DateTime
alias :name to fullName: DISL.FullName
alias :id to id: Guid

domain ATQR
  purpose "A platform for people to challenge each other to accomplish goals"

  concept Settings
    emails:
      retryDelay: $> number of emails sent * 2
      maxRetries: 3 times
      maxEmailsPerAddress: 5
      maxEmailsResetPeriod: 1 month

  //------------------------------
  // System events
  //------------------

  /**
   * Fired each new day at 00:00:01
   */
  ⏰ NewDayStarted!
    @date: DateTime

  context Challenges

    repository Notifications
      recordNotification NotificationMessage
      countNotifications
        params
          :userId
          optional inCategories: NotificationCategory[]
          optional sentVia: NotificationChannel[]

    aggregate ChallengeAggregate

      !ChallengeNotFound :challengeId

      root Challenge

        depends on PaymentService

        @createdByPlayer: boolean
          returns @owner.role == ParticipationRole.Player

        @createdByJudge: boolean
          returns @owner.role == ParticipationRole.Judge

        @players: Enrollment[]
        @judges: Officiation[]
        @status: ChallengeStatus = ChallengeStatus.Unverified
        @createAt: DateTime
          auto: Today

        ⚙️ recipe:
          @goalId: GoalId
          @owner: User
          /**
          * Holds all users ever invited to this challenge
          * and their participation status
          */
          @invitees: Contact[]
          @deadline: Date
          @pledge: DISL.Money
            greater than 0
          @deadline: FutureDate
          @requiredProof?: DISL.Paragraph
          /**
           * Allows players to enroll using a link instead of being invited
           * @param {boolean} true if players can enroll using a link
           */
          @inviteByLink: boolean
          @enrollmentDeadline: FutureDate
            before @deadline
          @owner: Contact
          ownerPaymentMethod: PaymentMethod | null

          when @createdByPlayer
            create new User for owner
              it's paymentMethod = ownerPaymentMethod

            createEnrollmentFor owner

        ⚙️ registerPlayer :name :email
          rules:
            when User with :email does not exist
              create new User with :name :email
                on SUCCESS:
                  show ui CheckEmailToConfirmParticipation
                on FAILURE:
                  throw "Could not create player"

        /**
         * Represents the intention of a player to accept a challenge
         */
        💬 AcceptChallenge? paymentInfo: Payment
          rules:
            when @status == ChallengeStatus.Ongoing do nothing

          if invitee is not found
            throw "Could not find invitee"

          invitee.status = ParticipationStatus.Accepted

          createEnrollmentFor invitee

          📣 ChallengeAccepted! :challengeId

        💬 RejectChallenge? :challengeId :inviteeEmail
          rules:
            when :challengeId not in Challenges
              throw ChallengeNotFound

            when @status == ChallengeStatus.Ongoing do nothing

          find invitee in @invitees where invitee.email == :inviteeEmail

          if invitee is not found
            throw "Could not find invitee"

          invitee.status = ParticipationStatus.Rejected

          📣 ChallengeRejected! :challengeId

        ⚙️ verifyIfChallengeCanBegin @players @judges @paymentMethods
          return allJudgeAccepted
            and  allPlayersAccepted
            and  allPaymentMethodsVerified

        ⚙️ allPlayersAccepted
          // code: this.invitees.find(invitee => invitee.role == player && invitee.participationStatus === ParticipationStatus.Accepted == false ? false : true)
          for each invitee with .role equals Player in @invitees
            if it's participationStatus is not Accepted
              return false

          return true

        ⚙️ allJudgesAccepted
          for each invitee with .role equals Judge in @invitees
            if it's participationStatus is not Accepted
              return false

        ⚙️ allPaymentMethodsVerified
          for each enrollment in @enrollments
            if it's PaymentFundsStatus is not Authorized
              return false

        ⚙️ createEnrollmentFor invitee
          create enrollment in @players for invitee
            it's pledge = 0
            it's paymentMethod = null
            it's paymentStatus = PaymentStatus.NotRequested
            it's paymentFundsStatus = PaymentFundsStatus.NotRequested

        ⚙️ verifyFunds
          params:
              :challengeId
              paymentMethod: PaymentMethod

          PaymentService.verifyFunds for @pledge and paymentMethod

          rules:
            when :paymentFundsStatus == PaymentFundsStatus.Available
              📣 fundsAvailable! :challengeId :paymentMethod
                sendChallengeCreatedEmailToPlayer? :challengeId

              when :supervisionStatus == SupervisionStatus.Accepted
                @status = ChallengeStatus.Ongoing
                📣 challengeOngoing! :challengeId
                  sendChallengeOngoingEmailToPlayer? :challengeId

            when :paymentFundsStatus == PaymentFundsStatus.Denied
              📣 challengeFailed! :challengeId
                sendChallengeFailedEmailToPlayer? :challengeId

            // if Supervisor has accepted the request then

        💬 rejectFundsRequest? :challengeId :paymentMethod
            @paymentMethod = PaymentFundsStatus.Denied
            📣 fundsDenied! :challengeId :paymentMethod
                sendPaymentMethodDeniedEmail? :challengeId

        💬 AcceptSupervisionRequest? :challengeId :supervisorId
          @supervisorStatus = SupervisionStatus.Accepted
          📣 supervisionRequestAccepted! :challengeId :supervisorId
            # if Funds are verified then
            when @paymentFundsStatus is PaymentFundsStatus.Available
              @status = ChallengeStatus.Ongoing

        command RejectSupervisionRequest?
          params:
            - challengeId: ChallengeId
            :supervisorId
          @supervisorStatus = SupervisionStatus.Rejected
          📣 supervisionRequestRejected! :challengeId :supervisorId
          sendSupervisorRejectedEmail? :challengeId

        💬 InviteNewSupervisor? :challengeId :supervisorName :supervisorEmail
          @supervisorStatus = SupervisionStatus.Requested
          sendSupervisionRequestedEmail? :challengeId
            📣 supervisionRequested! :challengeId

        💬 JudgeChallenge? :userId, accomplished: boolean

          rules:
            when @status is not ChallengeStatus.Overdue
              throw "Challenge is not ongoing"

            when there is no Enrollment for :userId
              throw "User is not a player in this challenge"

          @challengeJudgement = ChallengeJudgement.Judged
          @status = ChallengeStatus.Finished

          if ^accomplished
            @enrollments[0].outcome = PlayerOutcome.Accomplished
            📣 ChallengeAccomplished! this
          else
            @enrollments[0].outcome = PlayerOutcome.Failed
            📣 ChallengeFailed! this

        ⌛ DeadlineReached! :challengeId
          @status = ChallengeStatus.Overdue
          sendJudgementRequestEmail? :challengeId
            @challengeJudgement = ChallengeJudgement.Requested

        📧 ChallengeFailed!
          sendChallengeFailedEmail? :challengeId

      entity User
        @id: UserId { auto-generated }
        @emailConfirmed: boolean
        @playedChallenges: Enrollment[]
        @officiatedChallenges: Officiation[]
        @organizedChallenges: Challenge[]
        @notificationSettings:
          @channels: NotificationChannel[]
          @lists: NotificationList[]

        recipe:
          params:
            @name: DISL.FullName
            @email: DISL.EmailAddress { unique }

          📣 UserCreated! :user

        /**
         * Returns all unanswered challenge invitations
         */
        ⚙️ getPendingInvitations:
          returns The Challenges where this user is in .invitees[]
              AND .invitees[].status == ParticipationStatus.NotRequested

      entity PaymentMethod
        depends on PaymentService

        /**
         * The id of the payment method in the payment service
         */
        @foreignId: ForeignPaymentMethodId
        @type: PaymentMethodType
        @paymentService: "stripe"
        @futurePayments: Map<ChallengeId, FuturePaymentId>

        📧 CardCharged! :auth :amountInCents

        ⚙️ setupFuturePayment: amountInCents
          // TODO: Implement this

        /**
         * Uses Stripe to charge the card using the pre-authorization
         *
         * @param {PreAuthorization} auth The pre-authorization to use
         * @param {number} amountInCents The amount to charge in cents
         * @returns {boolean} Whether the charge was successful or not
         */
        ⚙️ charge
          params:
            foreignId: FuturePaymentId

          when PaymentService.capturePayment(foreignId) succeeds
            ⮐ SUCCESS
          else
            CardChargeFailed! :auth :amountInCents
            ⮐ FAILED

        ⚙️ ReleasePreAuth? :preAuthorization
