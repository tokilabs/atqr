``# import other DISL files
read_also enums.disl
read_also ui.disl

identity ChallengeId: Guid
identity UserId: Guid

alias :challenge challenge Challenge
alias :challengeId id ChallengeId
alias :userId id UserId
alias :dt date DateTime
alias :name fullName DISL.FullName
alias :id id Guid

domain ATQR
  purpose "A platform for people to challenge each other to accomplish goals"

context Challenges

  valueObject Contact
    @name: DISL.FullName
    @email: DISL.EmailAddress
    @role: ParticipationRole

  valueObject Invite extends Contact
    @status: ParticipationStatus = ParticipationStatus.NotRequested

  // Creates a new type that is a Guid to differentiate among Entity Ids
  // export type PlayerId = Guid
  identity PlayerId: Guid

  aggregate ChallengeAggregate

    !ChallengeNotFound :challengeId

    entity User
      @id: UserId { auto-generated }
      @name: DISL.FullName
      @email: DISL.EmailAddress { unique }
      @emailConfirmed: boolean
      @playedChallenges: Enrollment[]
      @officiatedChallenges: Officiation[]
      @paymentMethod?: PaymentMethod

      /**
       * Returns all unanswered challenge invitations
       */
      getPendingInvitations
        return The Challenges where this user is in .invitees[]
            AND .invitees[].status == ParticipationStatus.NotRequested

    /**
     * Represents a player's participation in a challenge
     */
    valueObject Enrollment
      @player: User
      @challenge: Challenge
      @playerAlias?: DISL.Name
      @pledge: DISL.Money
      @outcome: PlayerOutcome = null
      @paymentStatus: PaymentStatus = PaymentStatus.Pending
      @paymentMethod: PaymentMethod
      @paymentFundsStatus: PaymentFundsStatus = PaymentFundsStatus.Unverified

      rules:
        when user == judge
          throw "A player cannot be a judge of their own challenge"

    /**
     * Represents a User participation in a challenge as a Judge
     */
    valueObject Officiation
      @challenge: Challenge
      @judge: User
      @players: ChallengeEntry[]
      @participationStatus: ParticipationStatus = ParticipationStatus.NotRequested
      @judgementStatus: JudgementStatus = JudgementStatus.NotRequested

    root Challenge
      @owner: User
      @players: Enrollment[]
      @judges: Officiation[]
      /**
       * Holds all users ever invited to this challenge
       * and their participation status
       */
      @invitees: Map<UserId, ParticipationStatus>
      @status: ChallengeStatus = ChallengeStatus.Unverified
      @deadline: Date
      @createAt: DateTime { auto: Today }
      @createdByPlayer: boolean
        return @owner.role == ParticipationRole.Player

      /**
       * Creates a new challenge and notifies both the Player and the Supervisor
       */
      üí¨ CreateChallenge?
        params:
          - @goal: DISL.Phrase
              not empty
              less than 140 characters
          - @pledge: DISL.Money
              greater than 0
          - deadline: FutureDate
          - invitees: Contact[]
          - @requiredProof?: DISL.Paragraph
          /**
           * Allows players to enroll using a link instead of being invited
           * @param {boolean} true if players can enroll using a link
           */
          - @inviteByLink: boolean
          - @enrollmentDeadline: FutureDate
              before @deadline
          - owner: Contact[]
          - ownerPaymentMethod: PaymentMethod | null

        // We must create the User first to ensure
        // that we collect their email address (for marketing purposes)
        find_or_create new User from owner as @owner

        rules:
          when @createdByPlayer
            if @owner .paymentMethod is not defined
              throw "A player must have a payment method defined"

            if IPaymentService .authorizeCharge for @pledge and :paymentMethod FAILED
              throw "Could not authorize payment"

            @owner.paymentMethod = ownerPaymentMethod

            create new Enrollment in @players for @owner
              it's pledge = @pledge
              it's paymentMethod = ownerPaymentMethod
              it's paymentStatus = PaymentStatus.Pending
              it's paymentFundsStatus = PaymentFundsStatus.Authorized

            üì£ ChargeAuthorized! @owner @pledge :paymentMethod
            üì£ ChallengeCreated! this

            /*
            * //TODO: WantToShareYourChallenge? function to give challenge owner the possibility to share there challenge on social midia 
            */

          when not @createdByPlayer

            sendChallengeCreatedEmailToSupervisor? :challengeId
            sendYouHaveBeenChallengedEmail? :challengeId
              üì£ playerChallenged! :challengeId
        end rules

        @deadline = deadline


        // Create invites to track participation status
        for each invitee in invitees
          find_or_create new User for invitee
          then create new Invite for $newUser
            set $newInvite role to invitee.role
            set $newInvite status = ParticipationStatus.NotRequested
            then add $newInvite to @invitees

      /**
       * Creates a new player and fires a PlayerCreated event
       *
       * NOTE: Commands in DISL are semantic and do not always mean
       * that a method should be created with the same name.
       * In this case, the CreatePlayer command will be translated
       * to the Player entity's constructor.
       */
      üí¨ CreateUser? :name :email
        create new User with :name :email as :user
        üì£ UserCreated! :user

      üí¨ RegisterPlayer? :name :email
        rules:
          when Player with :email does not exist
            CreateUser? :name :email
              on SUCCESS:
                show ui CheckEmailToConfirmParticipation
              on FAILURE:
                throw "Could not create player"


      /**
       * Represents the intention of a player to accept a challenge
       */
      üí¨ AcceptChallenge? :challengeId paymentInfo: Payment
        rules:
          when :challengeId not in Challenges
            throw ChallengeNotFound
          when @status == ChallengeStatus.Ongoing do nothing

        @status = ChallengeStatus.Accepted
        üì£ challengeAccepted! :challengeId
          sendChallengeAcceptedEmailToPlayer? :challengeId
      üí¨ RejectChallenge? :challengeId

      üí¨ GetLastChallenges? :qty
        return the first :qty Challenges ordered by @creation_date descending
          source: database

      üìß fundsVerified! :challengeId :paymentFundsStatus
        rules:
          when :paymentFundsStatus == PaymentFundsStatus.Available
            üì£ fundsAvailable! :challengeId :paymentMethod
              sendChallengeCreatedEmailToPlayer? :challengeId

            when :supervisionStatus == SupervisionStatus.Accepted
              @status = ChallengeStatus.Ongoing
              üì£ challengeOngoing! :challengeId
                sendChallengeOngoingEmailToPlayer? :challengeId

          when :paymentFundsStatus == PaymentFundsStatus.Denied
            üì£ challengeFailed! :challengeId
              sendChallengeFailedEmailToPlayer? :challengeId

          # if Supervisor has accepted the request then
      üí¨ rejectFundsRequest? :challengeId :paymentMethod
          @paymentMethod = PaymentFundsStatus.Denied
          üì£ fundsDenied! :challengeId :paymentMethod
              sendPaymentMethodDeniedEmail? :challengeId

      üí¨ AcceptSupervisionRequest? :challengeId :supervisorId
        @supervisorStatus = SupervisionStatus.Accepted
        üì£ supervisionRequestAccepted! :challengeId :supervisorId
          # if Funds are verified then
          when @paymentFundsStatus is PaymentFundsStatus.Available
            @status = ChallengeStatus.Ongoing

      üí¨ RejectSupervisionRequest? :challengeId :supervisorId
        @supervisorStatus = SupervisionStatus.Rejected
        üì£ supervisionRequestRejected! :challengeId :supervisorId
        sendSupervisorRejectedEmail? :challengeId

      üí¨ InviteNewSupervisor? :challengeId :supervisorName :supervisorEmail
        @supervisorStatus = SupervisionStatus.Requested
        sendSupervisionRequestedEmail? :challengeId
          üì£ supervisionRequested! :challengeId


      üí¨ judgeChallenge? :challengeId, accomplished: boolean
        @challengeJudgement = ChallengeJudgement.Judged
        @status = accomplished ? ChallengeStatus.Accomplished : ChallengeStatus.Failed
        when accomplished
          üì£ ChallengeAccomplished! :challengeId
            sendChallengeAccomplishedEmail? :challengeId
        else
          üì£ ChallengeFailed! :challengeId

      /**
       * This is a cron job that runs every day and checks if any challenges are overdue
       *
       * ItsThatTimeAgain!
       *   @createdAt: DateTime
       */
      ‚è∞ NewDayStarted!
        for each :challenge in Challenges
          when .deadline is before Today
            üì£ DeadlineReached! :challengeId

          when .createdAt is before 2 days ago
           and .enrollmentDeadline is after Yesterday
            list all .invitees that
              - have not enrolled in :challengeId
              - have not been notified

            if list is not empty
              üì£ PlayersForgotToEnroll! :challengeId :list

          when .createdAt is before 5 days ago
           and .enrollmentDeadline is Today
            list all .invitees that
              - have not enrolled in :challengeId
              - have been notified at most once

            if list is not empty
              üì£ PlayersLastChanceToEnrollArrived! :challengeId :list

      ‚åõ DeadlineReached! :challengeId
        @status = ChallengeStatus.Overdue
        sendJudgementRequestEmail? :challengeId
          @challengeJudgement = ChallengeJudgement.Requested

      üìß ChallengeFailed!
        sendChallengeFailedEmail? :challengeId

    valueObject PreAuthorization
      @code: DISL.Token
      @amount: DISL.Money
      // TODO: Check if Stripe returns an authorization code
      @createdAt: DateTime
      /**
      * The authorization expires in 30 days
      */
      @expiresAt: DateTime
        // ‚óå - Not implemented
        // ‚óØ - Implemented
        // ‚óè - Implemented and in use
        rules ‚óå ‚óØ ‚óè
          ‚óå Is future date
          ‚óå Is before 31 days from @createdAt

    valueObject Email
      @to: EmailAddress
      @subject: string
      @body: string

    valueObject EmailTemplate
      @subject: string
      @body: string

    externalService EmailService
      send Email

    service NotificationService
      import * as Pug from 'pug'

      sendEmail template: EmailTemplate, data: Object, $to: EmailAddress
        {{using}} Pug
          parse template.subject with data as :subject
          parse template.body with data as :body
        create new Email $to with :subject and :body
        send ${it} {{using}} IEmailService

      üí¨ ChallengeCreated! challenge: Challenge
        sendEmail
          template: ChallengeCreatedEmail
          data: Challenge
          to: challenge.owner.email

        when challenge.createdByPlayer
          for each :contact in challenge.invitees
            if :contact.role is ContactRole.Judge
              send SupervisionRequestedEmail to challenge.invitees.email for challenge

        when not challenge.createdByPlayer
          for each :contact in challenge.invitees
            if :contact.role is ContactRole.Player
              send YouHaveBeenChallengedEmail to challenge.invitees.email for challenge

      üí¨ FundsAvailable!
          send ChallengeCreatedEmailToPlayer

      üí¨ FundsDenied!
          send PaymentMethodDeniedEmail

      üí¨ SupervisionRequested!
          send SupervisionRequestEmail

      üí¨ SupervisionRequestAccepted!
          send SupervisionRequestAccepted

      üí¨ SupervisionRequestRejected!
          send SupervisorRejectedEmail

      üí¨ ChallengeAccepted!
          send ChallengeAcceptedEmailToPlayer

      üí¨ ChallengeRejected!
          send ChallengeRejectedEmailToPlayer

      üí¨ ChallengeOngoing!
          send ChallengeOngoingEmailToPlayer

      üí¨ JudgeRequested!
          send JudgementRequestEmail

      üí¨ ChallengeAccomplished!
          send ChallengeAccomplishedEmail

      üí¨ ChallengeFailed!
          send ChallengeFailedEmail


    /**
    * Interface for a Service that handles payments
    * Implementation layer: Infrastructure
    */
    serviceInterface IPaymentService
      createCustomer from :contact => ForeignCustomerId

      createPaymentMethod for :customer with :paymentMethod
        return ForeignPaymentMethodId

      setupFuturePayment of :amount using :paymentMethod => FuturePaymentId

      capturePayment futurePaymentId
        // return SUCCESS or FAILURE
        return Whether it succeeded or not


    entity PaymentMethod
      /**
       * The id of the payment method in the payment service
       */
      @foreignId: ForeignPaymentMethodId
      @type: PaymentMethodType
      @paymentService: "stripe"
      @futurePayments: Map<ChallengeId, FuturePaymentId>

      üìß CardCharged! :auth :amountInCents

      üí¨ SetupFuturePayment? :amountInCents

      /**
       * Uses Stripe to charge the card using the pre-authorization
       *
       * @param {PreAuthorization} auth The pre-authorization to use
       * @param {number} amountInCents The amount to charge in cents
       * @returns {boolean} Whether the charge was successful or not
       */
      üí¨ Charge? foreignId: FuturePaymentId
        when IPaymentService.capturePayment(foreignId) succeeds
          ‚Æê SUCCESS
        else
          CardChargeFailed! :auth :amountInCents
          ‚Æê FAILED

      ‚åò releasePreAuth? :preAuthorization
    end

  service AccountService
    uses UserRepository

    createAccount for Contact
      rules:
        - Contact.email does not exist in UserRepository.users.email

  valueObject Icons
